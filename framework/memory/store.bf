[
Allocate heap memory (see dynamic-memory.md)

use "../case.bf"
use "../word.bf"
use "../helpers/test_helpers.bf"
]

>>>>>> >>>>>> >>>>>> >>>>>>
>>>>>> >>>>>> >>>>>> >>
>>>>>> >>>>> +++ >>>>>> +++
<<<<<< <<<<<< <<<<<
= 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | `0 0 0 0 | 0 0 | 0 0 0 0 | 0 3 | 0 0 0 0 | 0 3

Takes two word arguments; the heap address and the value to store in that address
store{
    = 0 * | * * * * | 0 * | * * * * | 0 * | * * * * | 0 * | * * * * | 0 * | * * * * | 0 * | * * * * | 0 * | `A0 A1 A2 A3 | 0 0 | V0 V1 V2 V3
    first we inflate the arguments
    [<<<<<< <<<<<< <<<<<< <<<<<< <<<<<< <<<<<< <<+>> >>>>>> >>>>>> >>>>>> >>>>>> >>>>>> >>>>>>-]>
    [<<<<<< <<<<<< <<<<<< <<<<<< <<<<<< <<<+>>> >>>>>> >>>>>> >>>>>> >>>>>> >>>>>>-]>
    [<<<<<< <<<<<< <<<<<< <<<<<< <<<<+>>>> >>>>>> >>>>>> >>>>>> >>>>>>-]>
    [<<<<<< <<<<<< <<<<<< <<<<<+>>>>> >>>>>> >>>>>> >>>>>>-]>>>
    = A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | 0 * | * * * * | 0 * | * * * * | 0 * | 0 0 0 0 | 0 0 | `V0 V1 V2 V3 | 0 *
    [<<<<<< <<<<<< <<<<<< <<+>> >>>>>> >>>>>> >>>>>>-]>
    [<<<<<< <<<<<< <<<+>>> >>>>>> >>>>>>-]>
    [<<<<<< <<<<+>>>> >>>>>>-]>
    [<<<<<+>>>>>-]>+
    = A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | 0 0 0 0 | V3 0 | 0 0 0 0 | `1 *
    drag both arguments to the start of the heap
    [
        = A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | `!0 * | * * * * | 0 a
        [-]
        <<<<<<[>>>>>>+<<<<<<-]
        <<<<<<[>>>>>>+<<<<<<-]
        <<<<<<[>>>>>>+<<<<<<-]
        <<<<<<[>>>>>>+<<<<<<-]
        <<<<<<[>>>>>>+<<<<<<-]
        <<<<<<[>>>>>>+<<<<<<-]
        <<<<<<[>>>>>>+<<<<<<-]
        <<<<<<[>>>>>>+<<<<<<-]
        >>>>>> >>>>>> >>>>>>
        >>>>>> >>>>>> >>>>>>
        >>>>>> >>>>>> >>>>>> +
        = 0 * | * * * * | A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | `1 a
        if a is nonzero (will always be 3 if not 0) set current cell to 0
        >[[-]<[-]>]<
        = 0 * | * * * * | A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | `a_was_zero 0 | * * * * | 0 *
    ]
    = A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | `0 0
    replace the 3 at the start of the heap
    >+++<
    = A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | `0 3
    go to the start of the address
    <<<<<< <<<<<< <<<<<< <<<<<<
    <<<<<< <<<<<< <<<<<< <<<<<<
    = `A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | 0 3
    loop until the most significant digit of the address drops to 0
    [
        = `A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | 0 a
        >>>>>>
        [
            = A0 * | * * * * | `A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 * | * * * * | 0 a

        ]

        move right
        >>>>>> >>>>>> >>>>>> >>>>>>
        >>>>>> >>>>>> >>>>>>
        [>>>>>>+<<<<<<-]<<<<<<
        [>>>>>>+<<<<<<-]<<<<<<
        [>>>>>>+<<<<<<-]<<<<<<
        [>>>>>>+<<<<<<-]<<<<<<
        [>>>>>>+<<<<<<-]<<<<<<
        [>>>>>>+<<<<<<-]<<<<<<
        [>>>>>>+<<<<<<-]<<<<<<
        [>>>>>>+<<<<<<-]
        >>>>>>
        = 0 * | * * * * | `A0 * | * * * * | A1 * | * * * * | A2 * | * * * * | A3 * | * * * * | V0 * | * * * * | V1 * | * * * * | V2 * | * * * * | V3 a
        decrement address
        >>>>>> >>>>>> >>>>>>

    ]
}

= ~
test_helpers/clear{ [-]->[-]>[-]>[-]++++++[<++++++[<++++++>-]>-]<<[>[-]<[>+<-]>-]+[[-]<+] }
>>>>>> >>>>>> >>>>>> >>>>>> >>>>>> >>>>>> >>>>>> >>>>>>

TEST: can store in addr 1000
= 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | `0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0
>>> + >>> ++++++ > +++++++ > ++++++++ > +++++++++ >> +++ >>>>>> ++ >>>>>> >>>> + >>> + > ++ > +++ > ++++ >> +++
<<<<<< <<<<<< <<<<<< <<<<<< <<<<<< <<<<<
= 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | `0 0 0 1 | 0 0 | 6 7 8 9 | 0 3 | 0 0 0 0 | 0 2 | 0 0 0 0 | 0 0 | 0 0 0 1 | 0 0 | 1 2 3 4 | 0 3
store{
}
/= 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | 0 0 0 0 | 0 0 | `0 0 0 0 | 0 0 | 0 0 0 0 | 0 3 | 0 0 0 0 | 0 2 | 0 0 0 0 | 0 0 | 0 0 0 1 | 0 0 | 6 7 8 9 | 0 3
= ~
